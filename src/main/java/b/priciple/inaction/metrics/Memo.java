package b.priciple.inaction.metrics;

/**
 * 需求：统计框架（非业务的通用框架）
 * 设计开发一个小的框架，能够获取接口调用的各种统计信息，
 * 如，响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps） 等，
 * 并且支持将统计结果以各种显示格式（比如：JSON 格式、网页格式、自定义显示格式等）
 * 输出到各种终端（Console 命令行、HTTP 网页、Email、日志文件、自定义输出终端等），以方便查看
 *
 *
 * 需求分析：
 * 1. 功能性需求分析
 *    - 拆解细分：把需求拆解为一个个单独的条目
 *    - 线框图：把最终数据的显示样式画出来
 * 2. 非功能性需求分析
 *    - 易用性：框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活、文档写得好坏
 *    - 扩展性：从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能
 *    - 容错性：不能因为框架本身的异常导致接口请求出错。所以要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、
 *    非运行时异常都进行捕获处理。
 *    - 通用性：除了接口统计这样一个需求，还可以适用到其他哪些场景中，比如是否还可以处理其他事件的统计信息，
 *    如 SQL 请求时间的统计信息、业务统计信息（比如支付成功率）等
 *
 *
 * 框架设计：
 * - 借鉴 TDD（测试驱动开发）和 Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型
 * - 先聚焦于一个具体、简单的应用场景：如统计注册、登录接口响应时间的最大和平均值、调用次数，并且将统计结果以 JSON 的格式输出到命令行中
 * - 一个粗略的系统设计图
 * - 把整个框架分为四个模块：数据采集、存储、聚合统计、显示
 *
 *
 * 面向对象设计与实现：
 * 1. 划分职责进而识别出有哪些类
 * - MetricsCollector 类负责提供 API，来采集接口请求的原始数据
 * - MetricsStorage 接口负责原始数据存储
 * - Aggregator 类负责根据原始数据计算统计数据
 * - ConsoleReporter 类、EmailReporter 类分别负责以一定频率统计并发送统计数据到命令行和邮件
 * 2. 定义类及类与类之间的关系
 * - 先在 IDE 中创建好这几个类，然后开始试着定义它们的属性和方法。
 * - 在设计类、类与类之间交互的时候，不断地用之前学过的设计原则和思想来审视设计是否合理
 * 3. 将类组装起来并提供执行入口
 * - 一个是 MetricsCollector 类，提供了一组 API 来采集原始数据
 * - 另一个是 ConsoleReporter 类和 EmailReporter 类，用来触发统计显示
 *
 *
 *
 * Review设计与实现：
 * - MetricsCollector
 * MetricsCollector 负责采集和存储数据，职责相对来说还算比较单一。
 * 它基于接口而非实现编程，通过依赖注入的方式来传递 MetricsStorage 对象，
 * 可以在不需要修改代码的情况下，灵活地替换不同的存储方式，满足开闭原则。
 * - MetricsStorage、RedisMetricsStorage
 * MetricsStorage 和 RedisMetricsStorage 的设计比较简单。当需要实现新的存储方式的时候，只需要实现 MetricsStorage 接口即可。
 * 因为所有用到 MetricsStorage 和 RedisMetricsStorage 的地方，都是基于相同的接口函数来编程的，
 * 所以，除了在组装类的地方有所改动（从 RedisMetricsStorage 改为新的存储实现类），其他接口函数调用的地方都不需要改动，满足开闭原则。
 * - Aggregator
 * Aggregator 类是一个工具类，里面只有一个静态函数，有 50 行左右的代码量，负责各种统计数据的计算。
 * 当需要扩展新的统计功能的时候，需要修改 aggregate() 函数代码，并且一旦越来越多的统计功能添加进来之后，这个函数的代码量会持续增加，
 * 可读性、可维护性就变差了。所以，从刚刚的分析来看，这个类的设计可能存在职责不够单一、不易扩展等问题，
 * 需要在之后的版本中，对其结构做优化。
 * - ConsoleReporter、EmailReporter
 * ConsoleReporter 和 EmailReporter 中存在代码重复问题。在这两个类中，从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，
 * 否则就违反了 DRY 原则。而且整个类负责的事情比较多，职责不是太单一。
 * 特别是显示部分的代码，可能会比较复杂（比如 Email 的展示方式），最好是将显示部分的代码逻辑拆分成独立的类。
 * 除此之外，因为代码中涉及线程操作，并且调用了 Aggregator 的静态函数，所以代码的可测试性不好。
 *
 *
 */
public class Memo {
}
