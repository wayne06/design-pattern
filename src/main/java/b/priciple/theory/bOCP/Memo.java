package b.priciple.theory.bOCP;

/**
 * Open Closed Principle: software entities (modules, classes, functions, etc.) should be open for extension, but closed
 * for modification.
 *
 * 如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，
 * 能够知道当下以及未来可能要支持的业务需求。
 *
 * 如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解
 * “它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题
 *
 * 最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，
 * 在编写代码的时候之后，我们就可以事先做些扩展性设计。
 * 但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，
 * 再通过重构代码的方式来支持扩展的需求
 *
 * 很多时候，我们都需要在扩展性和可读性之间做权衡
 *
 * 在之前的 Alert 告警的例子中，如果告警规则并不是很多、也不复杂，那 check() 函数中的 if 语句就不会很多，代码逻辑也不复杂，
 * 代码行数也不多，那最初的第一种代码实现思路简单易读，就是比较合理的选择。
 * 相反，如果告警规则很多、很复杂，check() 函数的 if 语句、代码逻辑就会很多、很复杂，相应的代码行数也会很多，
 * 可读性、可维护性就会变差，那重构之后的第二种代码实现思路就是更加合理的选择了
 *
 */
public class Memo {
}
