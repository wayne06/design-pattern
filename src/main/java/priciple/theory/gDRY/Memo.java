package priciple.theory.gDRY;

/**
 * 怎么提高代码的复用性？
 *
 * 减少代码耦合
 * 对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，
 * 往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。
 * 所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。
 *
 * 满足单一职责原则
 * 我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。
 * 根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。
 *
 * 模块化
 * 这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。
 * 独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。
 *
 * 业务与非业务逻辑分离
 * 越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。
 * 所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。
 * 通用代码下沉从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。
 * 一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，
 * 杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。
 *
 * 继承、多态、抽象、封装
 * 在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。
 * 利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。
 * 除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。
 * 代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。
 *
 * 应用模板等设计模式
 * 一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。
 * 关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。
 *
 * 还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等
 *
 *
 * 实际上，除非有非常明确的复用需求，否则为了暂时用不到的复用需求，花费太多时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。
 * 这也违反我们之前讲到的 YAGNI 原则
 *
 */
public class Memo {
}
