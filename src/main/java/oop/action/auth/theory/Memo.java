package oop.action.auth.theory;

/**
 * 需求：
 * 正在参与开发一个微服务，微服务通过 HTTP 协议暴露接口给其他系统调用。为了保证接口调用的安全性，需要设计实现一个接口调用鉴权功能：
 * 只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝
 *
 * 面向对象分析：
 * 面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。
 * 实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行。
 * 我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的
 * 1. 第一轮基础分析
 * 最简单的解决方案就是，通过用户名加密码来做认证。
 * 我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。
 * 调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。
 * 微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。
 * 如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。
 * 2. 第二轮分析优化
 * 密码很容易被截获，是不安全的。那如果我们借助加密算法（比如 SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？
 * 实际上，这样也是不安全的，因为加密之后的密码及 AppID，照样可以被未认证系统（或者说黑客）截获，
 * 未认证系统可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问我们的接口。这就是典型的“重放攻击”。
 * 3. 第三轮分析优化
 * 选择时间戳作为随机变量。原来的 token 是对 URL、AppID、密码三者进行加密生成的，
 * 现在我们将 URL、AppID、密码、时间戳四者进行加密来生成 token。
 * 调用方在进行接口请求的时候，将 token、AppID、时间戳，随 URL 一并传递给微服务端。
 * 微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。
 * 如果超过一分钟，则判定 token 过期，拒绝接口请求。
 * 如果没有超过一分钟，则说明 token 没有过期，就再通过同样的 token 生成算法，在服务端生成新的 token，
 * 与调用方传递过来的 token 比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求
 * 4. 第四轮分析优化
 * 攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。
 * 所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。
 * 针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。
 * 我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，
 * 能够在我们切换存储方式的时候，尽可能地减少代码的改动。
 * 5. 最终需求确定
 * - 调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，
 * 并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。
 * - 微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。
 * - 微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，
 * 拒绝接口调用请求。
 * - 如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，
 * 生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。
 *
 * 面向对象设计：
 * 面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类
 * - 划分职责进而识别出有哪些类；
 * 根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类
 * - 定义类及其属性和方法；
 * 识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性
 * - 定义类与类之间的交互关系；
 * 从更加贴近编程的角度，对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖
 * - 将类组装起来并提供执行入口
 * 接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件，
 * 所以，我们封装所有的实现细节，设计了一个最顶层的 ApiAuthenticator 接口类，暴露一组给外部调用者使用的 API 接口，
 * 作为触发执行鉴权逻辑的入口
 *
 * 面向对象编程：
 * 见 code
 */
public class Memo {
}
